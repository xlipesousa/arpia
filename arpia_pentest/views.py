from __future__ import annotations

import json
import shlex
import subprocess
from dataclasses import dataclass, asdict
from typing import Any, Optional
from uuid import UUID

from django.contrib.auth.mixins import LoginRequiredMixin
from django.db.models import Count, Max, Q
from django.http import JsonResponse
from django.utils import timezone
from django.views import View
from django.views.generic import TemplateView

from arpia_core.models import ObservedEndpoint, Project
from arpia_core.views import build_project_macros
from arpia_hunt.models import HuntAlert, HuntFinding
from arpia_scan.models import ScanSession
from arpia_vuln.models import VulnScanSession, VulnerabilityFinding


SSH_INTERACTIVE_TIMEOUT = 10
CRITICAL_SCAN_PORTS = {
	21,
	22,
	23,
	25,
	53,
	80,
	110,
	135,
	139,
	143,
	389,
	443,
	445,
	465,
	993,
	995,
	1433,
	1521,
	2049,
	3306,
	3389,
	5432,
	5900,
	5985,
	5986,
	8080,
	8443,
}


def _normalize_host_tokens(value) -> list[str]:
	if not value:
		return []

	if isinstance(value, (list, tuple, set)):
		tokens = value
	else:
		cleaned = str(value).replace(",", "\n").replace(";", "\n")
		tokens = cleaned.splitlines()

	normalized: list[str] = []
	for token in tokens:
		segment = str(token).strip()
		if segment:
			normalized.append(segment)
	return normalized


def _extract_ssh_targets(macros: dict) -> tuple[list[dict[str, str]], list[str]]:
	hosts = _normalize_host_tokens(macros.get("TARGET_HOSTS"))
	credentials = macros.get("CREDENTIALS_TABLE") or []
	combinations: list[dict[str, str]] = []
	unique_hosts = set(hosts)
	seen: set[tuple[str, str, str]] = set()

	if isinstance(credentials, list):
		for entry in credentials:
			if not isinstance(entry, dict):
				continue

			username = (entry.get("username") or "").strip()
			password = entry.get("password") or ""
			if not username or not password:
				continue

			target_field = entry.get("target") or entry.get("host") or ""
			targets = _normalize_host_tokens(target_field) if target_field else hosts
			targets = [item for item in targets if item]
			if not targets:
				continue

			for target in targets:
				key = (target, username, password)
				if key in seen:
					continue
				seen.add(key)
				combinations.append(
					{
						"host": target,
						"username": username,
						"password": password,
					}
				)
				unique_hosts.add(target)

	return combinations, sorted(unique_hosts)


def _list_accessible_projects(user) -> list[Project]:
	if not user or not getattr(user, "is_authenticated", False):
		return []
	return list(
		Project.objects.filter(Q(owner=user) | Q(memberships__user=user))
		.distinct()
		.order_by("-created")
	)


def _select_project(projects: list[Project], requested_id: str | None) -> Project | None:
	if requested_id:
		for project in projects:
			if str(project.pk) == str(requested_id):
				return project
	return projects[0] if projects else None


def _get_project_for_user(user, project_id: str | None) -> Project | None:
	if not user or not getattr(user, "is_authenticated", False) or not project_id:
		return None
	try:
		target_uuid = UUID(str(project_id))
	except (TypeError, ValueError):
		return None
	return (
		Project.objects.filter(Q(owner=user) | Q(memberships__user=user), pk=target_uuid)
		.distinct()
		.first()
	)


def _format_datetime(value, *, default: str = "—") -> str:
	if not value:
		return default
	try:
		localized = timezone.localtime(value)
	except Exception:
		localized = value
	return localized.strftime("%d/%m %H:%M")


def _format_time(value, *, default: str = "—") -> str:
	if not value:
		return default
	try:
		localized = timezone.localtime(value)
	except Exception:
		localized = value
	return localized.strftime("%H:%M")


def _summary_from_stats(snapshot: dict[str, Any] | None) -> dict[str, Any]:
	if not isinstance(snapshot, dict):
		return {}
	stats = snapshot.get("stats") if isinstance(snapshot.get("stats"), dict) else {}
	return stats or {}


def _build_scan_module(project: Project | None) -> PentestModule:
	if not project:
		return PentestModule(
			slug="scan",
			name="ARPIA Scan",
			summary="Selecione um projeto para carregar as métricas de superfície exposta e serviços identificados.",
			key_metrics=[
				{"label": "Sessões ativas", "value": 0},
				{"label": "Hosts descobertos", "value": 0},
				{"label": "Portas críticas", "value": 0},
			],
			highlights=["Carregue um projeto para acompanhar hosts e portas expostas."],
			activity_log=[],
		)

	sessions_qs = ScanSession.objects.filter(project=project).only("title", "status", "started_at", "finished_at", "report_snapshot").order_by("-created_at")
	running_sessions = sessions_qs.filter(status=ScanSession.Status.RUNNING).count()
	endpoints_qs = ObservedEndpoint.objects.filter(asset__project=project)
	unique_hosts = endpoints_qs.values("ip").distinct().count()
	critical_services = (
		endpoints_qs.filter(port__in=CRITICAL_SCAN_PORTS).values("ip", "port").distinct().count()
	)
	host_port_totals = list(
		endpoints_qs.values("ip").annotate(port_count=Count("id"), last_seen=Max("last_seen")).order_by("-port_count", "-last_seen")[:5]
	)
	latest_session = sessions_qs.filter(status__in=[ScanSession.Status.COMPLETED, ScanSession.Status.RUNNING, ScanSession.Status.FAILED]).order_by("-finished_at", "-created_at").first()
	stats_snapshot = _summary_from_stats(latest_session.report_snapshot if latest_session else None)
	key_metrics = [
		{"label": "Sessões ativas", "value": running_sessions},
		{"label": "Hosts descobertos", "value": unique_hosts},
		{"label": "Portas críticas", "value": critical_services},
	]
	highlights: list[str] = []
	if latest_session:
		status_label = latest_session.get_status_display()
		finished_label = _format_datetime(latest_session.finished_at or latest_session.started_at)
		total_findings = stats_snapshot.get("total_findings")
		piece = f"{status_label} — {latest_session.title} ({finished_label})"
		if total_findings:
			piece += f" · {int(total_findings)} achado(s)"
		highlights.append(piece)
	if host_port_totals:
		top_host = host_port_totals[0]
		highlights.append(
			f"Host {top_host['ip']} com {top_host['port_count']} serviço(s) exposto(s)."
		)
	if critical_services:
		common_ports_sample = sorted(CRITICAL_SCAN_PORTS)[:4]
		common_str = ", ".join(str(port) for port in common_ports_sample)
		highlights.append(
			f"{critical_services} serviço(s) identificados em portas sensíveis (ex.: {common_str})."
		)
	if not highlights:
		highlights.append("Nenhum endpoint coletado pelas últimas execuções.")
	activity_log: list[dict[str, str]] = []
	for session in sessions_qs[:6]:
		snapshot = _summary_from_stats(session.report_snapshot)
		hosts_snapshot = snapshot.get("hosts_count")
		findings_snapshot = snapshot.get("total_findings")
		detail_parts = [session.get_status_display()]
		if hosts_snapshot:
			detail_parts.append(f"{int(hosts_snapshot)} host(s)")
		if findings_snapshot:
			detail_parts.append(f"{int(findings_snapshot)} achado(s)")
		activity_log.append(
			{
				"time": _format_time(session.finished_at or session.started_at or session.created_at),
				"event": session.title,
				"detail": " • ".join(detail_parts),
			}
		)
	if not activity_log:
		activity_log.append(
			{
				"time": "—",
				"event": "Sem execuções registradas",
				"detail": "Dispare uma sessão de scan para preencher a linha do tempo.",
			}
		)
	return PentestModule(
		slug="scan",
		name="ARPIA Scan",
		summary=f"Superfície atual: {unique_hosts} host(s) monitorado(s) e {critical_services} porta(s) sensível(is) identificada(s).",
		key_metrics=key_metrics,
		highlights=highlights,
		activity_log=activity_log,
	)


def _build_vuln_module(project: Project | None) -> PentestModule:
	if not project:
		return PentestModule(
			slug="vuln",
			name="ARPIA Vuln",
			summary="Selecione um projeto para visualizar os achados de vulnerabilidade correlacionados.",
			key_metrics=[
				{"label": "Vulnerabilidades críticas", "value": 0},
				{"label": "Findings abertos", "value": 0},
				{"label": "Hosts afetados", "value": 0},
			],
			highlights=["Nenhuma vulnerabilidade carregada — selecione um projeto."],
			activity_log=[],
		)

	findings_qs = VulnerabilityFinding.objects.filter(session__project=project)
	critical_count = findings_qs.filter(severity=VulnerabilityFinding.Severity.CRITICAL).count()
	open_findings = findings_qs.exclude(status=VulnerabilityFinding.Status.RESOLVED).count()
	affected_hosts = findings_qs.exclude(host="").values("host").distinct().count()
	top_findings = list(
		findings_qs.order_by("-cvss_score", "-detected_at", "-created_at").select_related("session")[:4]
	)
	latest_sessions = VulnScanSession.objects.filter(project=project).order_by("-started_at", "-created_at")[:5]
	key_metrics = [
		{"label": "Vulnerabilidades críticas", "value": critical_count},
		{"label": "Findings abertos", "value": open_findings},
		{"label": "Hosts afetados", "value": affected_hosts},
	]
	highlights: list[str] = []
	for finding in top_findings:
		score = finding.display_score
		target = finding.host or finding.service or "alvo não identificado"
		label = finding.cve or finding.title
		highlights.append(f"{label} (CVSS {score}) em {target}.")
	if not highlights:
		highlights.append("Nenhum finding correlacionado até o momento.")
	activity_log: list[dict[str, str]] = []
	for session in latest_sessions:
		status_label = session.get_status_display()
		detail_parts = [status_label]
		if session.started_at and session.finished_at:
			duration = (session.finished_at - session.started_at).total_seconds()
			if duration:
				detail_parts.append(f"{int(duration // 60)} min")
		activity_log.append(
			{
				"time": _format_time(session.finished_at or session.started_at or session.created_at),
				"event": session.title,
				"detail": " • ".join(detail_parts),
			}
		)
	if not activity_log:
		activity_log.append(
			{
				"time": "—",
				"event": "Sem correlações recentes",
				"detail": "Execute uma sessão de vulnerabilidades para popular estes dados.",
			}
		)
	return PentestModule(
		slug="vuln",
		name="ARPIA Vuln",
		summary=f"{open_findings} vulnerabilidade(s) aberta(s) — {critical_count} classificada(s) como crítica.",
		key_metrics=key_metrics,
		highlights=highlights,
		activity_log=activity_log,
	)


def _build_hunt_module(project: Project | None) -> PentestModule:
	if not project:
		return PentestModule(
			slug="hunt",
			name="ARPIA Hunt",
			summary="Selecione um projeto para acompanhar alertas ativos e pontos de persistência.",
			key_metrics=[
				{"label": "Alertas ativos", "value": 0},
				{"label": "Findings ativos", "value": 0},
				{"label": "Hosts comprometidos", "value": 0},
			],
			highlights=["Nenhum alerta carregado — selecione um projeto."],
			activity_log=[],
		)

	active_findings_qs = HuntFinding.objects.filter(project=project, is_active=True)
	active_alerts_qs = HuntAlert.objects.filter(finding__project=project, is_active=True).select_related("finding")
	alert_count = active_alerts_qs.count()
	active_findings_count = active_findings_qs.count()
	compromised_hosts = active_findings_qs.exclude(host="").values("host").distinct().count()
	top_active_findings = list(
		active_findings_qs.order_by("-cvss_score", "-detected_at", "-created_at")[:4]
	)
	key_metrics = [
		{"label": "Alertas ativos", "value": alert_count},
		{"label": "Findings ativos", "value": active_findings_count},
		{"label": "Hosts comprometidos", "value": compromised_hosts},
	]
	highlights: list[str] = []
	for finding in top_active_findings:
		label = finding.cve or finding.vulnerability.title
		severity = finding.get_severity_display()
		target = finding.host or finding.service or "alvo não identificado"
		score = f"CVSS {finding.cvss_score:.1f}" if finding.cvss_score is not None else "Sem CVSS"
		highlights.append(f"{label} ({severity}) em {target} — {score}.")
	if not highlights:
		highlights.append("Nenhum beacon ou credencial ativa correlacionada.")
	activity_log: list[dict[str, str]] = []
	for alert in active_alerts_qs.order_by("-last_triggered_at", "-created_at")[:6]:
		event = alert.get_kind_display()
		detail = alert.finding.cve or alert.finding.vulnerability.title
		activity_log.append(
			{
				"time": _format_time(alert.last_triggered_at),
				"event": event,
				"detail": detail,
			}
		)
	if not activity_log:
		activity_log.append(
			{
				"time": "—",
				"event": "Sem alertas ativos",
				"detail": "Sincronize o módulo Hunt para acompanhar persistências.",
			}
		)
	return PentestModule(
		slug="hunt",
		name="ARPIA Hunt",
		summary=f"{alert_count} alerta(s) ativo(s) correlacionado(s) às vulnerabilidades do projeto.",
		key_metrics=key_metrics,
		highlights=highlights,
		activity_log=activity_log,
	)


@dataclass
class PentestModule:
	slug: str
	name: str
	summary: str
	key_metrics: list[dict[str, Any]]
	highlights: list[str]
	activity_log: list[dict[str, str]]

	def as_dict(self) -> dict[str, Any]:
		return asdict(self)


class PentestDashboardView(TemplateView):
	template_name = "pentest/dashboard.html"

	def get_context_data(self, **kwargs):  # type: ignore[override]
		context = super().get_context_data(**kwargs)

		projects = _list_accessible_projects(self.request.user)
		selected_project = _select_project(projects, self.request.GET.get("project"))
		selected_project_id = str(selected_project.pk) if selected_project else ""
		modules = [
			_build_scan_module(selected_project),
			_build_vuln_module(selected_project),
			_build_hunt_module(selected_project),
		]
		macros = build_project_macros(self.request.user, selected_project) if selected_project else {}
		ssh_targets, ssh_hosts = _extract_ssh_targets(macros)
		ssh_demo = {
			"target_count": len(ssh_targets),
			"hosts": ssh_hosts,
			"project_id": selected_project_id,
			"project_name": selected_project.name if selected_project else "",
			"has_project": selected_project is not None,
		}

		context.update(
			{
				"modules": [module.as_dict() for module in modules],
				"default_module": modules[0].slug,
				"initial_terminal_lines": [
					"┌─[pentest@arpia]─[~/ops/initial-access]",
					"└──$ sudo ./weaponize --target=GATEWAY-01 --profile=stealth",
					"[+] Carregando payload modulado...",
					"[+] Pivot configurado via SSH dynamic forward (1080)",
					"┌─[pentest@arpia]─[~/ops/post-exploitation]",
					"└──$ python3 session_manager.py --list",
					"# ID  HOSTNAME     USER        LAST_SEEN      ACCESS",
					"  07  DMZ-WEB01    nt_author   2m atrás       beacon_http",
					"  12  CORE-DB02    sa_service  5m atrás       meterpreter_tcp",
					"└──$ _",
				],
				"ssh_demo": ssh_demo,
				"projects": projects,
				"selected_project": selected_project,
				"selected_project_id": selected_project_id,
			}
		)
		return context


class PentestTerminalCommandView(LoginRequiredMixin, View):
	http_method_names = ["post"]

	def post(self, request, *args, **kwargs):
		try:
			payload = json.loads(request.body.decode("utf-8"))
		except (json.JSONDecodeError, UnicodeDecodeError):
			payload = {}

		command = (payload.get("command") or "").strip()
		if not command:
			return JsonResponse({"error": "Comando vazio."}, status=400)

		if len(command) > 512:
			return JsonResponse({"error": "Comando muito extenso."}, status=400)

		try:
			completed = subprocess.run(
				command,
				shell=True,
				check=False,
				capture_output=True,
				text=True,
				executable="/bin/bash",
				timeout=30,
			)
		except subprocess.TimeoutExpired:
			return JsonResponse(
				{
					"command": command,
					"stdout": "",
					"stderr": "Tempo limite excedido (30s).",
					"returncode": -1,
				},
				status=200,
			)
		except Exception as exc:  # pragma: no cover - defensive
			return JsonResponse({"error": f"Falha ao executar: {exc}"}, status=500)

		return JsonResponse(
			{
				"command": command,
				"stdout": completed.stdout,
				"stderr": completed.stderr,
				"returncode": completed.returncode,
			}
		)


class PentestSSHBatchTestView(LoginRequiredMixin, View):
	http_method_names = ["post"]

	def post(self, request, *args, **kwargs):
		try:
			payload = json.loads(request.body.decode("utf-8"))
		except (json.JSONDecodeError, UnicodeDecodeError):
			payload = {}

		project_id = (payload.get("project") or "").strip() if isinstance(payload, dict) else ""
		if not project_id:
			project_id = (request.GET.get("project") or "").strip()

		project = _get_project_for_user(request.user, project_id)
		if not project:
			return JsonResponse({"error": "Projeto inválido ou sem acesso."}, status=404)

		macros = build_project_macros(request.user, project)
		ssh_targets, _ = _extract_ssh_targets(macros)
		if not ssh_targets:
			return JsonResponse(
				{"error": "Nenhuma credencial com senha disponível nas macros do projeto."},
				status=400,
			)

		attempt_lines: list[str] = [
			f"[hunt] {len(ssh_targets)} combinações recebidas das macros do projeto {project.name}."
		]
		last_returncode = -1
		last_replay_command: Optional[str] = None
		last_wrapped_command: Optional[str] = None

		for entry in ssh_targets:
			host = entry.get("host", "")
			username = entry.get("username", "")
			password = entry.get("password", "")
			if not host or not username or not password:
				attempt_lines.append("[hunt] Combinação inválida detectada nas macros. Pulando.")
				continue

			attempt_lines.append(f"[hunt] Tentando acesso SSH para {username}@{host} ...")
			interactive_capture = [
				"timeout",
				str(SSH_INTERACTIVE_TIMEOUT),
				"sshpass",
				"-p",
				password,
				"ssh",
				"-tt",
				"-o",
				"StrictHostKeyChecking=no",
				"-o",
				"UserKnownHostsFile=/dev/null",
				"-o",
				"GlobalKnownHostsFile=/dev/null",
				"-o",
				"PreferredAuthentications=password",
				"-o",
				"HostKeyAlgorithms=+ssh-rsa",
				"-o",
				"PubkeyAcceptedAlgorithms=+ssh-rsa",
				"-o",
				"LogLevel=ERROR",
				"-o",
				"ConnectTimeout=6",
				f"{username}@{host}",
				"/bin/sh",
				"-lc",
				(
					"HOST=$(hostname 2>/dev/null || echo unknown); "
					"USER=$(whoami 2>/dev/null || echo unknown); "
					"KERNEL=$(uname -sr 2>/dev/null || echo unknown); "
					"printf -- '[remote] Host: %s\\n' \"$HOST\"; "
					"printf -- '[remote] User: %s\\n' \"$USER\"; "
					"printf -- '[remote] Kernel: %s\\n' \"$KERNEL\"; "
					"printf '\\n'; "
					"exec /bin/sh -l"
				),
			]
			replay_command = shlex.join(interactive_capture)
			wrapped_command = _wrap_command_for_terminal(replay_command)
			last_replay_command = replay_command
			last_wrapped_command = wrapped_command

			try:
				completed = subprocess.run(
					interactive_capture,
					shell=False,
					check=False,
					capture_output=True,
					text=True,
					timeout=15,
				)
			except FileNotFoundError:
				return JsonResponse(
					{
						"error": "Ferramenta 'sshpass' não encontrada no host Kali.",
						"missing_dependency": "sshpass",
					},
					status=500,
				)
			except subprocess.TimeoutExpired:
				attempt_lines.append("[hunt] Tentativa expirou após 15s.")
				last_returncode = -1
				continue
			except Exception as exc:  # pragma: no cover - defensivo
				return JsonResponse({"error": f"Falha ao executar teste SSH: {exc}"}, status=500)

			last_returncode = completed.returncode
			stdout = (completed.stdout or "").strip()
			stderr = (completed.stderr or "").strip()
			if stdout:
				attempt_lines.append(stdout)
			if stderr:
				filtered_stderr = "\n".join(
					line
					for line in stderr.splitlines()
					if not line.lower().startswith("timeout:")
				)
				if filtered_stderr:
					attempt_lines.append(filtered_stderr)

			if completed.returncode in (0, 124):
				attempt_lines.append(f"[hunt] Credencial válida confirmada para {username}@{host}.")
				if completed.returncode == 124:
					attempt_lines.append(f"[hunt] Sessão interativa encerrada após {SSH_INTERACTIVE_TIMEOUT}s para evitar bloqueio do terminal.")
				attempt_lines.append("[hunt] Para reproduzir manualmente o teste execute:")
				attempt_lines.append(wrapped_command)
				return JsonResponse(
					{
						"command": "macro:ssh_batch",
						"stdout": "\n".join(attempt_lines),
						"stderr": "",
						"returncode": completed.returncode,
						"matched": {
							"host": host,
							"username": username,
						},
						"project_id": str(project.pk),
						"replay_command": replay_command,
					}
				)

			attempt_lines.append(f"[hunt] Falha ao autenticar {username}@{host} (exit {completed.returncode}).")
			attempt_lines.append("[hunt] Comando executado para este teste:")
			attempt_lines.append(wrapped_command)

		attempt_lines.append("[hunt] Nenhuma credencial validou acesso SSH.")
		return JsonResponse(
			{
				"command": "macro:ssh_batch",
				"stdout": "\n".join(attempt_lines),
				"stderr": "",
				"returncode": last_returncode,
				"matched": None,
				"project_id": str(project.pk),
				"replay_command": last_replay_command,
				"replay_command_wrapped": last_wrapped_command,
			}
		)


def _wrap_command_for_terminal(command: str, limit: int = 80) -> str:
	lines: list[str] = []
	current_tokens: list[str] = []
	current_length = 0

	for token in command.split(" "):
		token_length = len(token)
		projected_length = token_length if not current_tokens else current_length + 1 + token_length

		if current_tokens and projected_length > limit:
			lines.append(" ".join(current_tokens) + " \\")
			current_tokens = [token]
			current_length = token_length
		else:
			if current_tokens:
				current_tokens.append(token)
				current_length = projected_length
			else:
				current_tokens = [token]
				current_length = token_length

	if current_tokens:
		lines.append(" ".join(current_tokens))

	return "\n".join(lines)
