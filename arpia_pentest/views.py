from __future__ import annotations

import json
import shlex
import subprocess
from dataclasses import dataclass, asdict
from typing import Any, Optional
from uuid import UUID

from django.contrib.auth.mixins import LoginRequiredMixin
from django.db.models import Q
from django.http import JsonResponse
from django.views import View
from django.views.generic import TemplateView

from arpia_core.models import Project
from arpia_core.views import build_project_macros


SSH_INTERACTIVE_TIMEOUT = 10


def _normalize_host_tokens(value) -> list[str]:
	if not value:
		return []

	if isinstance(value, (list, tuple, set)):
		tokens = value
	else:
		cleaned = str(value).replace(",", "\n").replace(";", "\n")
		tokens = cleaned.splitlines()

	normalized: list[str] = []
	for token in tokens:
		segment = str(token).strip()
		if segment:
			normalized.append(segment)
	return normalized


def _extract_ssh_targets(macros: dict) -> tuple[list[dict[str, str]], list[str]]:
	hosts = _normalize_host_tokens(macros.get("TARGET_HOSTS"))
	credentials = macros.get("CREDENTIALS_TABLE") or []
	combinations: list[dict[str, str]] = []
	unique_hosts = set(hosts)
	seen: set[tuple[str, str, str]] = set()

	if isinstance(credentials, list):
		for entry in credentials:
			if not isinstance(entry, dict):
				continue

			username = (entry.get("username") or "").strip()
			password = entry.get("password") or ""
			if not username or not password:
				continue

			target_field = entry.get("target") or entry.get("host") or ""
			targets = _normalize_host_tokens(target_field) if target_field else hosts
			targets = [item for item in targets if item]
			if not targets:
				continue

			for target in targets:
				key = (target, username, password)
				if key in seen:
					continue
				seen.add(key)
				combinations.append(
					{
						"host": target,
						"username": username,
						"password": password,
					}
				)
				unique_hosts.add(target)

	return combinations, sorted(unique_hosts)


def _list_accessible_projects(user) -> list[Project]:
	if not user or not getattr(user, "is_authenticated", False):
		return []
	return list(
		Project.objects.filter(Q(owner=user) | Q(memberships__user=user))
		.distinct()
		.order_by("-created")
	)


def _select_project(projects: list[Project], requested_id: str | None) -> Project | None:
	if requested_id:
		for project in projects:
			if str(project.pk) == str(requested_id):
				return project
	return projects[0] if projects else None


def _get_project_for_user(user, project_id: str | None) -> Project | None:
	if not user or not getattr(user, "is_authenticated", False) or not project_id:
		return None
	try:
		target_uuid = UUID(str(project_id))
	except (TypeError, ValueError):
		return None
	return (
		Project.objects.filter(Q(owner=user) | Q(memberships__user=user), pk=target_uuid)
		.distinct()
		.first()
	)


@dataclass
class PentestModule:
	slug: str
	name: str
	summary: str
	key_metrics: list[dict[str, Any]]
	highlights: list[str]
	activity_log: list[dict[str, str]]

	def as_dict(self) -> dict[str, Any]:
		return asdict(self)


class PentestDashboardView(TemplateView):
	template_name = "pentest/dashboard.html"

	def get_context_data(self, **kwargs):  # type: ignore[override]
		context = super().get_context_data(**kwargs)

		modules = [
			PentestModule(
				slug="scan",
				name="ARPIA Scan",
				summary="Varreduras de superfície exposta, portas prioritárias e fingerprint de serviços.",
				key_metrics=[
					{"label": "Sessões ativas", "value": 2},
					{"label": "Hosts descobertos", "value": 18},
					{"label": "Portas críticas", "value": 11},
				],
				highlights=[
					"Rustscan executado contra perímetro externo às 18:11",
					"Fingerprint atualizado com 6 novos serviços HTTP",
					"Repositório DNS enumerado com sucesso (zone transfer parcial)",
				],
				activity_log=[
					{"time": "18:11", "event": "Rustscan", "detail": "Top 1000 TCP + UDP"},
					{"time": "18:05", "event": "Nmap NSE", "detail": "Scripts default,safe"},
					{"time": "17:58", "event": "Subfinder", "detail": "34 subdomínios válidos"},
				],
			),
			PentestModule(
				slug="vuln",
				name="ARPIA Vuln",
				summary="Correlação de vulnerabilidades, CVEs priorizados e integração Greenbone.",
				key_metrics=[
					{"label": "CVEs críticos", "value": 4},
					{"label": "Findings confirmados", "value": 12},
					{"label": "Exploit disponíveis", "value": 3},
				],
				highlights=[
					"CVE-2023-38408 explorável — OpenSSH agent forwarding",
					"Greenbone entregou relatório de alta criticidade (9.8)",
					"Plano de exploração atualizado para o ativo GATEWAY-01",
				],
				activity_log=[
					{"time": "18:14", "event": "Exploit PoC", "detail": "OpenSSH Agent"},
					{"time": "17:45", "event": "Greenbone", "detail": "Scan completo - Perfil Deep"},
					{"time": "17:20", "event": "Parser CVE", "detail": "Score CVSS recalculado"},
				],
			),
			PentestModule(
				slug="hunt",
				name="ARPIA Hunt",
				summary="Telemetria pós-exploração, persistência e alerta de atividades suspeitas.",
				key_metrics=[
					{"label": "Alertas ativos", "value": 5},
					{"label": "Sessões persistentes", "value": 3},
					{"label": "Hosts comprometidos", "value": 6},
				],
				highlights=[
					"Detecção de lateral movement via WinRM no segmento interno",
					"Implant de beacon HTTP ativo na zona DMZ há 42 minutos",
					"Novo alerta de credencial exposta em repositório Git interno",
				],
				activity_log=[
					{"time": "18:19", "event": "Beacon", "detail": "Callback estável"},
					{"time": "18:02", "event": "Credential Dump", "detail": "Hash NTLM coletado"},
					{"time": "17:37", "event": "Alert", "detail": "Bruteforce RDP bloqueado"},
				],
			),
		]

		projects = _list_accessible_projects(self.request.user)
		selected_project = _select_project(projects, self.request.GET.get("project"))
		selected_project_id = str(selected_project.pk) if selected_project else ""
		macros = build_project_macros(self.request.user, selected_project) if selected_project else {}
		ssh_targets, ssh_hosts = _extract_ssh_targets(macros)
		ssh_demo = {
			"target_count": len(ssh_targets),
			"hosts": ssh_hosts,
			"project_id": selected_project_id,
			"project_name": selected_project.name if selected_project else "",
			"has_project": selected_project is not None,
		}

		context.update(
			{
				"modules": [module.as_dict() for module in modules],
				"default_module": modules[0].slug,
				"initial_terminal_lines": [
					"┌─[pentest@arpia]─[~/ops/initial-access]",
					"└──$ sudo ./weaponize --target=GATEWAY-01 --profile=stealth",
					"[+] Carregando payload modulado...",
					"[+] Pivot configurado via SSH dynamic forward (1080)",
					"┌─[pentest@arpia]─[~/ops/post-exploitation]",
					"└──$ python3 session_manager.py --list",
					"# ID  HOSTNAME     USER        LAST_SEEN      ACCESS",
					"  07  DMZ-WEB01    nt_author   2m atrás       beacon_http",
					"  12  CORE-DB02    sa_service  5m atrás       meterpreter_tcp",
					"└──$ _",
				],
				"ssh_demo": ssh_demo,
				"projects": projects,
				"selected_project": selected_project,
				"selected_project_id": selected_project_id,
			}
		)
		return context


class PentestTerminalCommandView(LoginRequiredMixin, View):
	http_method_names = ["post"]

	def post(self, request, *args, **kwargs):
		try:
			payload = json.loads(request.body.decode("utf-8"))
		except (json.JSONDecodeError, UnicodeDecodeError):
			payload = {}

		command = (payload.get("command") or "").strip()
		if not command:
			return JsonResponse({"error": "Comando vazio."}, status=400)

		if len(command) > 512:
			return JsonResponse({"error": "Comando muito extenso."}, status=400)

		try:
			completed = subprocess.run(
				command,
				shell=True,
				check=False,
				capture_output=True,
				text=True,
				executable="/bin/bash",
				timeout=30,
			)
		except subprocess.TimeoutExpired:
			return JsonResponse(
				{
					"command": command,
					"stdout": "",
					"stderr": "Tempo limite excedido (30s).",
					"returncode": -1,
				},
				status=200,
			)
		except Exception as exc:  # pragma: no cover - defensive
			return JsonResponse({"error": f"Falha ao executar: {exc}"}, status=500)

		return JsonResponse(
			{
				"command": command,
				"stdout": completed.stdout,
				"stderr": completed.stderr,
				"returncode": completed.returncode,
			}
		)


class PentestSSHBatchTestView(LoginRequiredMixin, View):
	http_method_names = ["post"]

	def post(self, request, *args, **kwargs):
		try:
			payload = json.loads(request.body.decode("utf-8"))
		except (json.JSONDecodeError, UnicodeDecodeError):
			payload = {}

		project_id = (payload.get("project") or "").strip() if isinstance(payload, dict) else ""
		if not project_id:
			project_id = (request.GET.get("project") or "").strip()

		project = _get_project_for_user(request.user, project_id)
		if not project:
			return JsonResponse({"error": "Projeto inválido ou sem acesso."}, status=404)

		macros = build_project_macros(request.user, project)
		ssh_targets, _ = _extract_ssh_targets(macros)
		if not ssh_targets:
			return JsonResponse(
				{"error": "Nenhuma credencial com senha disponível nas macros do projeto."},
				status=400,
			)

		attempt_lines: list[str] = [
			f"[hunt] {len(ssh_targets)} combinações recebidas das macros do projeto {project.name}."
		]
		last_returncode = -1
		last_replay_command: Optional[str] = None
		last_wrapped_command: Optional[str] = None

		for entry in ssh_targets:
			host = entry.get("host", "")
			username = entry.get("username", "")
			password = entry.get("password", "")
			if not host or not username or not password:
				attempt_lines.append("[hunt] Combinação inválida detectada nas macros. Pulando.")
				continue

			attempt_lines.append(f"[hunt] Tentando acesso SSH para {username}@{host} ...")
			interactive_capture = [
				"timeout",
				str(SSH_INTERACTIVE_TIMEOUT),
				"sshpass",
				"-p",
				password,
				"ssh",
				"-tt",
				"-o",
				"StrictHostKeyChecking=no",
				"-o",
				"UserKnownHostsFile=/dev/null",
				"-o",
				"GlobalKnownHostsFile=/dev/null",
				"-o",
				"PreferredAuthentications=password",
				"-o",
				"HostKeyAlgorithms=+ssh-rsa",
				"-o",
				"PubkeyAcceptedAlgorithms=+ssh-rsa",
				"-o",
				"LogLevel=ERROR",
				"-o",
				"ConnectTimeout=6",
				f"{username}@{host}",
				"/bin/sh",
				"-lc",
				(
					"HOST=$(hostname 2>/dev/null || echo unknown); "
					"USER=$(whoami 2>/dev/null || echo unknown); "
					"KERNEL=$(uname -sr 2>/dev/null || echo unknown); "
					"printf -- '[remote] Host: %s\\n' \"$HOST\"; "
					"printf -- '[remote] User: %s\\n' \"$USER\"; "
					"printf -- '[remote] Kernel: %s\\n' \"$KERNEL\"; "
					"printf '\\n'; "
					"exec /bin/sh -l"
				),
			]
			replay_command = shlex.join(interactive_capture)
			wrapped_command = _wrap_command_for_terminal(replay_command)
			last_replay_command = replay_command
			last_wrapped_command = wrapped_command

			try:
				completed = subprocess.run(
					interactive_capture,
					shell=False,
					check=False,
					capture_output=True,
					text=True,
					timeout=15,
				)
			except FileNotFoundError:
				return JsonResponse(
					{
						"error": "Ferramenta 'sshpass' não encontrada no host Kali.",
						"missing_dependency": "sshpass",
					},
					status=500,
				)
			except subprocess.TimeoutExpired:
				attempt_lines.append("[hunt] Tentativa expirou após 15s.")
				last_returncode = -1
				continue
			except Exception as exc:  # pragma: no cover - defensivo
				return JsonResponse({"error": f"Falha ao executar teste SSH: {exc}"}, status=500)

			last_returncode = completed.returncode
			stdout = (completed.stdout or "").strip()
			stderr = (completed.stderr or "").strip()
			if stdout:
				attempt_lines.append(stdout)
			if stderr:
				filtered_stderr = "\n".join(
					line
					for line in stderr.splitlines()
					if not line.lower().startswith("timeout:")
				)
				if filtered_stderr:
					attempt_lines.append(filtered_stderr)

			if completed.returncode in (0, 124):
				attempt_lines.append(f"[hunt] Credencial válida confirmada para {username}@{host}.")
				if completed.returncode == 124:
					attempt_lines.append(f"[hunt] Sessão interativa encerrada após {SSH_INTERACTIVE_TIMEOUT}s para evitar bloqueio do terminal.")
				attempt_lines.append("[hunt] Para reproduzir manualmente o teste execute:")
				attempt_lines.append(wrapped_command)
				return JsonResponse(
					{
						"command": "macro:ssh_batch",
						"stdout": "\n".join(attempt_lines),
						"stderr": "",
						"returncode": completed.returncode,
						"matched": {
							"host": host,
							"username": username,
						},
						"project_id": str(project.pk),
						"replay_command": replay_command,
					}
				)

			attempt_lines.append(f"[hunt] Falha ao autenticar {username}@{host} (exit {completed.returncode}).")
			attempt_lines.append("[hunt] Comando executado para este teste:")
			attempt_lines.append(wrapped_command)

		attempt_lines.append("[hunt] Nenhuma credencial validou acesso SSH.")
		return JsonResponse(
			{
				"command": "macro:ssh_batch",
				"stdout": "\n".join(attempt_lines),
				"stderr": "",
				"returncode": last_returncode,
				"matched": None,
				"project_id": str(project.pk),
				"replay_command": last_replay_command,
				"replay_command_wrapped": last_wrapped_command,
			}
		)


def _wrap_command_for_terminal(command: str, limit: int = 80) -> str:
	lines: list[str] = []
	current_tokens: list[str] = []
	current_length = 0

	for token in command.split(" "):
		token_length = len(token)
		projected_length = token_length if not current_tokens else current_length + 1 + token_length

		if current_tokens and projected_length > limit:
			lines.append(" ".join(current_tokens) + " \\")
			current_tokens = [token]
			current_length = token_length
		else:
			if current_tokens:
				current_tokens.append(token)
				current_length = projected_length
			else:
				current_tokens = [token]
				current_length = token_length

	if current_tokens:
		lines.append(" ".join(current_tokens))

	return "\n".join(lines)
